╔══════════════════════════════════════════════════════════════════════════════╗
║              СВОДКА ИЗМЕНЕНИЙ: УЛУЧШЕНИЕ ЛОГИКИ ПАРСИНГА                      ║
║                           06.02.2026                                         ║
╚══════════════════════════════════════════════════════════════════════════════╝

ЧТО ИЗМЕНЕНО:
────────────────────────────────────────────────────────────────────────────

1. Добавлен метод shouldParse() в файл:
   📁 src/shared/managers/vacancyManager.ts

   Метод проверяет историю парсинга из таблицы ParseLog ПЕРВЫМ делом и
   принимает решение о необходимости запуска парсинга.

2. Обновлен метод searchRegular() - теперь использует shouldParse() для
   принятия решения ДО проверки данных в БД.

КАК ЭТО РАБОТАЕТ:
────────────────────────────────────────────────────────────────────────────

До изменений:
  1. Проверяем БД → 0 вакансий
  2. → Запускаем парсинг (даже если парсинг был 5 минут назад!)

После изменений:
  1. Проверяем историю в ParseLog
  2. Если парсинг был недавно (< 12 часов):
     - Вернул 0 вакансий → НЕ парсим снова
     - Вернул вакансии → проверяем БД с фильтрами
       * Есть вакансии по фильтрам → НЕ парсим
       * Нет вакансий по фильтрам → парсим для обновления
  3. Если парсинга не было или устарел (> 12 часов) → парсим

ПРИМЕРЫ:
────────────────────────────────────────────────────────────────────────────

✅ Первый запрос "Уборщица" → парсим (парсинга никогда не было)
✅ Второй запрос "Уборщица" через 5 минут → НЕ парсим (был недавно)
✅ Запрос "НесуществующаяПрофессия123" → парсим 1 раз → НЕ парсим повторно
✅ Запрос с фильтром salaryMin=1000000 → НЕ парсим (если парсинг был недавно)

РАЗНИЦА МЕЖДУ ПАРАМЕТРАМИ:
────────────────────────────────────────────────────────────────────────────

| Параметр | Что делает | Когда применяется |
|----------|------------|-------------------|
| searchBy=title | Ищет в БД по полям title ИЛИ category | Обычный поиск. НЕ использует словарики для парсинга. |
| searchBy=category | Ищет в БД только по полю category | Поиск по каноническому названию профессии |
| useSemanticSearch=true | 1. Делает семантический маппинг через словарики → 2. Парсит с ТОЧНЫМИ названиями из sourceMappings → 3. Ищет в БД по оригинальному запросу | Только при первом парсинге или когда данных нет в БД |

КЛЮЧЕВОЙ МОМЕНТ:
────────────────────────────────────────────────────────────────────────────

Механизм determineCategory() (определение категории из канонического
справочника) работает ПРИ СОХРАНЕНИИ вакансий, а не при поиске:

- При парсинге → вакансия получает поле category = "Уборщица"
- При поиске с searchBy=title&keywords=Уборщица → ищет в title ИЛИ category
- При поиске с useSemanticSearch=true&keywords=cleaner → маппит "cleaner" → 
  "Уборщица" → парсит с названиями из sourceMappings для каждого источника

ЧТО ДЕЛАТЬ:
────────────────────────────────────────────────────────────────────────────

1. Изменения уже применены в коде
2. Пересобрать проект:
   $ npm run build

3. Перезапустить сервер:
   $ npm run start

4. Проверить работу:
   $ curl "http://localhost:3000/api/vacancies?keywords=Уборщица&workLocationType=abroad"

РЕЗУЛЬТАТ:
────────────────────────────────────────────────────────────────────────────

✅ Фильтр workLocationType исправлен (конвертация 'abroad' → 'За границей')
✅ Поиск по ключевым словам теперь ищет в title ИЛИ category
✅ Логика парсинга улучшена: проверка истории из ParseLog ПЕРВОЙ
✅ Семантический поиск работает только при useSemanticSearch=true
✅ Избегаем повторного парсинга "пустых" запросов

ДОКУМЕНТАЦИЯ:
────────────────────────────────────────────────────────────────────────────

- PARSING_OPTIMIZATION.md - подробное описание изменений
- README_FIX.md - исправление фильтров
- SOLUTION_REPORT.md - полный отчет по проблеме с фильтрами
